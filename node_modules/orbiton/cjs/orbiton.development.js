'use strict';

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
function createId(name, key = null) {
  if (key === null || key === undefined) {
    key = Math.floor(Math.random() * 100000000);
    return Symbol(`${name}_random_generated_key_${key}`);
  }

  return Symbol(`${name}_provided_key_${key}`);
}

class Config {
  static renderer = null;

  static registerRender(renderer) {
    if (renderer !== null) {
      throw new Error("The renderer instance can only be initiated Once in an Enviromemt");
    }

    if ("updateUI" in renderer === false) {
      throw new Error("Provided Renderer lacks `updateUI` function");
    } else {
      this.renderer = renderer;
    }
  }

}

const COMPONENT_TYPE = "Component";
const ELEMENT_TYPE = "element";

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
function compareState(oldComponent, newComponent) {
  const finalComponent = newComponent;
  finalComponent.state = oldComponent.state;
  return finalComponent;
}
function PatchTrees(currentTree, newTree) {
  if (newTree === undefined) {
    return newTree;
  } // Diffing Instances
  // - Element and Element
  // - Component and Element
  // - Component and Component
  // - Fragment and Component
  // - Fragment and Element
  // - Fragment and Fragment
  // - attached Components


  if (currentTree.type !== newTree.type) {
    return newTree;
  } else if (currentTree.type === "element" && newTree.type === "element") {
    return CompareAndPatchElement(currentTree, newTree);
  } else if (currentTree.type === "Component" && newTree.type === "Component") {
    const newComp = compareState(currentTree, newTree);
    newComp.currentTree = PatchTrees(currentTree.currentTree, newComp.render());
    return newComp;
  } else if (currentTree.type === "Fragment" && newTree.type === "Fragment") {
    const children = CompareAndPatchChildren(currentTree.children, newTree.children);
    newTree.children = children;
    return newTree;
  }
}
function PatchChildrenTrees(currentTree, newTree) {
  if (newTree === undefined || currentTree === undefined) {
    return newTree;
  } // Diffing Instances
  // - Element and Element
  // - Component and Element
  // - Component and Component
  // - Fragment and Component
  // - Fragment and Element
  // - Fragment and Fragment
  // - attached Components


  if (typeof currentTree === "string" || typeof newTree === "string") {
    return newTree;
  } else if (currentTree.type !== newTree.type) {
    return newTree;
  } else if (currentTree.type === ELEMENT_TYPE && newTree.type === ELEMENT_TYPE) {
    return CompareAndPatchElement(currentTree, newTree);
  } else if (currentTree.type === COMPONENT_TYPE && newTree.type === COMPONENT_TYPE) {
    return compareState(currentTree, newTree);
  } else {
    return newTree;
  }
}

function CompareAndPatchElement(oldElement, newElement) {
  const resultElement = newElement;

  if (oldElement.attachedComponent !== newElement.attachedComponent) {
    return newElement;
  }

  if (oldElement.tag !== newElement.tag) {
    return newElement;
  }

  resultElement.children = CompareAndPatchChildren(oldElement.children, newElement.children);
  return resultElement;
}

function CompareAndPatchChildren(oldChildren, newChildren) {
  const children = [];
  oldChildren.forEach((oldChild, i) => {
    const newChild = newChildren[i];
    children.push(PatchChildrenTrees(oldChild, newChild));
  });

  for (const additionalChild of newChildren.slice(oldChildren.length)) {
    children.push(additionalChild);
  }

  return children;
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
* Base component
*/

class BaseComponent {
  constructor(props = {}, context = {}) {
    this.state = {};
    this.props = props;
    this.context = context;
  }
  /**
  * Updates a subset of the state in the class
  * @param {object} newState this subset that you want to update
  * @param {?Function} callBack this callback function that is called after state updates
  */


  changeState(newState, callBack = null) {
    if (newState.constructor.name !== 'Object') {
      throw Error('updateState(...) method takes in an object');
    }

    const values = Object.getOwnPropertyNames(newState);
    const stateValues = Object.getOwnPropertyNames(this.state);

    for (const value of values) {
      if (stateValues.includes(value)) {
        this.state[value] = newState[value];
      } else {
        throw Error('The value `' + value + '` is not in the state object');
      }
    }

    if (callBack !== null) {
      callBack.call(this, newState);
    }
  }

}
class LogicalComponent extends BaseComponent {
  static isClassComponent = true;

  constructor(props = {}, context = {}) {
    super(props, context);

    if (props !== {}) {
      this.key = props ? props.key ? props.key : null : null;
    }

    this.type = 'Component';
    this.pearlId = createId(this.constructor.name, this.key);
    this.Mounted = this.Mounted.bind(this);
    this.WillMount = this.WillMount.bind(this);
    this.getPearlId = this.getPearlId.bind(this);
    this.updateState = this.updateState.bind(this);
    this.changeState = this.changeState.bind(this);
  }

  getPearlId() {
    return this.pearlId;
  }

  Mounted() {}

  WillMount() {}
  /**
  * Updates a subset of the state in the class
  * @param {any} newState this subset that you want to update
  * @param {?Function} callback this callback function that is called after state updates
  *
  * */


  updateState(newState, callback = null) {
    this.changeState(newState, callback);
  }

}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
* Creates a new Element
*/

function createElement(tag, options) {
  const {
    attributes = {},
    events = {},
    children = []
  } = options;
  return {
    tag,
    attributes,
    events,
    children,
    type: 'element'
  };
}

const withComponent = (tag, component, options) => {
  const {
    attributes = {},
    events = {},
    children = [],
    props = {}
  } = options;
  return {
    tag,
    attributes,
    events,
    children,
    type: 'element',
    attachedComponent: createComponent(component, props),
    props: props
  };
};

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
* Creates a new Component
*/

function createComponent(comp, props = {}, context = {}) {
  if (typeof comp === "function") {
    if (comp.isClassComponent) {
      const c = new comp(props, context);
      return c;
    }

    if (comp.isFragment) {
      const c = new comp(props.children);
      return c;
    } // Returns if the component was a Fuctional Component


    return comp(props);
  }

  if (typeof comp === 'string') {
    const opts = props;
    return createElement(comp, opts);
  } // If the component was a Variable
  // This stops the error encountered when initalising Mdx


  return comp;
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
class Fragment {
  static isFragment = true;

  constructor(children) {
    const key = Math.floor(Math.random() * 100000000);
    this.FragmentID = createId(`Fragment_Type`, `by_fragment_${key}`);
    this.children = children;
    this.type = "Fragment";
    this.getPearlId = this.getPearlId.bind(this);
  }

  getPearlId() {
    return this.FragmentID;
  }

}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
function appendChild$1(node, child) {
  if (Array.isArray(child)) {
    for (const childEl of child) {
      appendChild$1(node, childEl);
    }
  } else {
    node.appendChild(child);
  }
}
function remove(node) {
  if (Array.isArray(node)) {
    for (const childEl of node) {
      remove(childEl);
    }
  } else {
    node.remove();
  }
}
function nodeValue(node) {
  if (Array.isArray(node)) {
    throw new Error("Cannot extract node value from array");
  } else {
    return node.nodeValue;
  }
}
function replaceWith(node, replacingNode) {
  if (Array.isArray(node)) {
    let index = node.length;

    while (index > 1) {
      const poped = node.pop();
      poped.remove();
      index--;
    }
    /** @type HTMLELement */


    const poped = node.pop();

    if (Array.isArray(replacingNode)) {
      poped.replaceWith(...destructureArrays(replacingNode));
    } else {
      poped.replaceWith(replacingNode);
    }
  } else {
    if (Array.isArray(replacingNode)) {
      node.replaceWith(...destructureArrays(replacingNode));
    } else {
      node.replaceWith(replacingNode);
    }
  }
}
function destructureArrays(array) {
  const finalArray = [];

  for (let i = 0; i < array.length; i++) {
    const element = array[i];

    if (Array.isArray(element)) {
      const destrItems = destructureArrays(element);

      for (const item of destrItems) {
        finalArray.push(item);
      }
    } else {
      finalArray.push(element);
    }
  }

  return finalArray;
}
function childNodes(node) {
  if (Array.isArray(node)) {
    return node;
  }

  return node.childNodes;
}
function allDocumentNodes() {
  const allNodes = document.querySelectorAll('*');
  const result = []; // eslint-disable-next-line @typescript-eslint/no-unused-vars

  allNodes.forEach((el, _) => {
    const childNodes = el.childNodes;
    result.push(el);

    for (const child of childNodes) {
      if (child instanceof Text) {
        result.push(child);
      }
    }
  });
  return result;
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
const hasUpperCaseRegex = /[A-Z]/;

function splitProperty(property, index, append) {
  const firstSection = property.slice(0, index);
  let secondSection = property.slice(index);
  secondSection = secondSection.toLowerCase();
  return `${firstSection}${append}${secondSection}`;
}
/**
* @param {string} property -
*/


function getPropety(property) {
  let validProperty = property;
  const upperCaseLetters = validProperty.match(hasUpperCaseRegex) || [];

  if (upperCaseLetters.length) {
    for (let i = 0; i < upperCaseLetters.length; i++) {
      const element = upperCaseLetters[i];

      if (property.indexOf(element) !== 0) {
        validProperty = splitProperty(validProperty, property.indexOf(element), '-');
      }
    }
  }

  return validProperty;
}
/**
* Appends attributes to a node
* @param {HTMLElement} node - Node to append attributes to
* @param {object} attributes - attributes
*/

function evaluateAttributes(node, attributes = {}) {
  for (const [property, value] of Object.entries(attributes)) {
    if (property === "style") {
      node.setAttribute(property, evaluateStyleTag(value));
    } else if (property.toLowerCase() === "classname") {
      node.setAttribute("class", value);
    } else {
      node.setAttribute(getPropety(property), value);
    }
  }

  return node;
}
/**
* @param {string} property -
* @param {number} index -
* @param {string} append -
* @return {string} .
*/

function splitCSSProperty(property, index, append) {
  const firstSection = property.slice(0, index);
  let secondSection = property.slice(index);
  secondSection = secondSection.toLowerCase();
  return `${firstSection}${append}${secondSection}`;
}

function getValidCSSFromObject(o) {
  let style = '';

  if (Array.isArray(o)) {
    throw new Error("Style prop only accepts as string os an object arrays ar not accepted");
  }

  for (const [property, value] of Object.entries(o)) {
    const UpperCaseLetters = property.match(hasUpperCaseRegex);

    if (UpperCaseLetters !== null) {
      if (UpperCaseLetters.length === 1) {
        /** @typedef string */
        const beginningOfSecondWord = UpperCaseLetters[0];
        const position = property.indexOf(beginningOfSecondWord); // split the word to add a dash `-` sign between them

        const CSSProperty = splitCSSProperty(property, position, '-');
        style = `${style}${CSSProperty}: ${getValue(value)};`;
      }
    } else {
      style = `${style}${property}: ${getValue(value)};`;
    }
  }

  return style;
}

function getValue(value) {
  if (typeof value === "number") {
    return `${value}px`;
  }

  return value;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function evaluateStyleTag(tag) {
  if (typeof tag === "object") {
    return getValidCSSFromObject(tag);
  }

  return tag;
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
function render(node, options = {
  ns: "http://www.w3.org/1999/xhtml"
}, ns = "http://www.w3.org/1999/xhtml") {
  if (Array.isArray(node)) {
    // This might happen when you call the render function on `props.children`
    const children = [];

    for (const child of node) {
      children.push(render(child, options, ns));
    }

    return children;
  }

  if (typeof node === "string" || typeof node === "boolean" || typeof node === "number") {
    return renderText(`${node}`, options);
  }

  if (node.type === "element") {
    return renderElement(node, options, ns);
  }

  if (node.type === "Component") {
    return renderComponent(node, options);
  }

  if (node.type === "Fragment") {
    return renderFragment(node, options);
  }
}

function renderElement(element, options = {
  ns: "http://www.w3.org/1999/xhtml"
}, ns = "http://www.w3.org/1999/xhtml") {
  let node;
  let childns;

  if (element.tag === "svg") {
    node = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    childns = "http://www.w3.org/2000/svg";
  } else if (ns !== "http://www.w3.org/1999/xhtml") {
    node = document.createElementNS(ns, element.tag);
    childns = ns;
  } else {
    node = document.createElement(element.tag);
    childns = "http://www.w3.org/1999/xhtml";
  }

  node.__ORBITON_CONFIG__ = {};

  if (options.parentNotElement) {
    node.__ORBITON_CONFIG__.__nonElement_parents_hosted = options.parents;
  }

  if (element.attachedComponent) {
    node.__ORBITON_CONFIG__.attachedComponent = element.attachedComponent;
  }

  evaluateAttributes(node, element.attributes);
  appendEvents$1(node, element.events);

  if (element.children && element.children.length > 0) {
    const childOptions = {
      ns: element.tag === "svg" ? "http://www.w3.org/2000/svg" : options.ns
    };

    for (const child of element.children) {
      if (Array.isArray(child)) {
        // This is documented at https://orbiton.js.org/docs/learn/list-rendering
        // This is usually possible when one maps through an array forexample:
        // render() {
        //   return (
        //     <div>
        //       {this.state.array.map(...)}
        //     </div>
        //   )
        // }
        for (const item of child) {
          const childNode = render(item, childOptions, childns);
          appendChild(node, childNode);
        }
      } else {
        const childNode = render(child, childOptions, childns);
        appendChild(node, childNode);
      }
    }
  }

  element.domRef = node;
  node.__ORBITON_CONFIG__.__element = element;
  return node;
}

function renderText(string, options) {
  const node = document.createTextNode(string);
  node.__ORBITON_CONFIG__ = {};

  if (options.parentNotElement) {
    node.__ORBITON_CONFIG__.__nonElement_parents_hosted = options.parents;
  }

  return node;
}

function renderComponent(component, options) {
  const element = component.makeChild();
  options.parentNotElement = true;

  if (options.parents && Array.isArray(options.parents)) ; else {
    options.parents = [];
  } /// We use array destructuring to prevent the runtime from creating the parents variable by reference to `options.parents`
  /// If it is referenced, each time a component in pushed to the varents variable, it will also be pushed to the initial options.parents making each element in the tree have the same array of parents.


  const parents = [...options.parents];
  parents.push(component);
  const childOpts = { ...options,
    parents: parents
  };
  const childNode = render(element, childOpts);

  if (Array.isArray(childNode)) {
    return [...childNode];
  } else {
    return [childNode];
  }
}

function renderFragment(fragment, options) {
  const children = [];
  options.parentNotElement = true;

  if (Array.isArray(options.parents) === false) {
    options.parents = [];
  }

  if (fragment.children.length === 0) {
    throw new Error("A fragment Always return have a child element.");
  }

  for (const child of fragment.children) {
    const parents = [...options.parents];
    parents.push(fragment);
    const childOpts = { ...options,
      parents: parents
    };
    const childNode = render(child, childOpts);

    if (Array.isArray(childNode)) {
      children.push(...childNode);
    } else {
      children.push(childNode);
    }
  }

  return children;
}

function appendEvents$1(node, events) {
  node.__ORBITON_CONFIG__.extendEvents = events;

  for (const [k, v] of Object.entries(events)) {
    node.addEventListener(k, v);
  }
}

function appendChild(node, child) {
  if (Array.isArray(child)) {
    for (const childEl of child) {
      appendChild(node, childEl);
    }
  } else {
    node.appendChild(child);
  }
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
* Appends events to a node that is passed in
* @param {OrbitonDOMElement|OrbitonSVGElement} node - The node to append the events
* @param {Record<string, VoidFunction>} events - an object containing the key as the event and the value as the function
*/
function appendEvents(node, events) {
  //console.log(events)
  node.__ORBITON_CONFIG__.extendEvents = events;

  for (const [k, v] of Object.entries(events)) {
    node.addEventListener(k, v);
  }
}
function patchNewEventListners(oldEvents, newEvents, node) {
  // eslint-disable-next-line no-use-before-define
  removeFromeNode(node);
  appendEvents(node, newEvents);
  return node;
}
function removeFromeNode(node) {
  for (const [k, v] of Object.entries(node.__ORBITON_CONFIG__.extendEvents)) {
    node.removeEventListener(k, v);
  }
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
 * Trigers the `Mounted` lifecycle method of any component within the node
 */

function triggerMountedLifeCycle(node, component = null) {
  if ("__ORBITON_CONFIG__" in node) {
    if (Array.isArray(node.__ORBITON_CONFIG__.__nonElement_parents_hosted)) {
      if (node.__ORBITON_CONFIG__.attachedComponent) {
        node.__ORBITON_CONFIG__.attachedComponent.Mounted();
      }

      if (component !== null) {
        const startIndex = node.__ORBITON_CONFIG__.__nonElement_parents_hosted.indexOf(component);

        node.__ORBITON_CONFIG__.__nonElement_parents_hosted.forEach((comp, ind) => {
          if (comp.type === "Component" && ind >= startIndex) {
            comp.Mounted();
          }
        });
      } else {
        node.__ORBITON_CONFIG__.__nonElement_parents_hosted.forEach((comp, ind) => {
          if (comp.type === "Component") {
            comp.Mounted();
          }
        });
      }
    }
  }

  if (Array.isArray(node)) {
    childNodes(node).forEach((child, i) => {
      triggerMountedLifeCycle(child, component);
    });
  } else {
    node.childNodes.forEach((child, i) => {
      triggerMountedLifeCycle(child);
    });
  }
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

function getParentComponentsAndFrags(node, parent) {
  let checkingNode;

  if (Array.isArray(node)) {
    checkingNode = node[0];
  } else {
    checkingNode = node;
  }

  const hosts = [];

  for (const item of checkingNode.__ORBITON_CONFIG__.__nonElement_parents_hosted) {
    if (item === parent) {
      break;
    } else {
      hosts.push(item);
    }
  }

  return hosts;
}

function isStringInstance(value) {
  if (typeof value === 'string' || value instanceof String || typeof value === 'number' || value instanceof Number || typeof value === 'boolean' || value instanceof Boolean) {
    return true;
  } else {
    return false;
  }
}

function diffAndPatch(oldTree, newTree, node, parentNode = null) {
  if (newTree === undefined || oldTree === undefined) {
    if (newTree === undefined && oldTree === undefined) {
      return;
    } else {
      if (newTree === undefined) {
        remove(node);
        return node;
      } else {
        const newNode = render(newTree);
        appendChild$1(parentNode, newNode);
        return newNode;
      }
    }
  }

  if (isStringInstance(oldTree) || isStringInstance(newTree)) {
    let nodeValue$1;

    try {
      nodeValue$1 = nodeValue(node);
    } catch (error) {
      nodeValue$1 = undefined;
    } // incase one of the trees is a string
    // we check if the nodeValue od the DOM node is equal to the newTree
    // if its not equal then we replace it with the new string
    // If they are equal we just return the same node


    if (nodeValue$1 !== `${newTree}`) {
      const newNode = render(newTree);
      replaceWith(node, newNode);
      triggerMountedLifeCycle(newNode);
      return newNode;
    } else {
      return node;
    }
  }

  if (oldTree.type !== newTree.type) {
    // If the types are not the same we should just render a new Dom Tree.
    let newNode;

    if (oldTree.type !== "element") {
      const opts = {
        parentNotElement: true,
        parents: getParentComponentsAndFrags(node, oldTree)
      };
      newNode = render(newTree, opts);
    } else {
      newNode = render(newTree);
    }

    replaceWith(node, newNode);
    triggerMountedLifeCycle(newNode);
    return newNode;
  }

  if (oldTree.type === "element" && newTree.type === "element") {
    return diffAndPatchElement(oldTree, newTree);
  }

  if (oldTree.type === "Fragment" && newTree.type === "Fragment") {
    ingenimateChildren(oldTree.children, newTree.children, node);
    return node;
  }

  if (oldTree.type === "Component" && newTree.type === "Component") {
    return DiffAndPatchComponent(oldTree, newTree, node);
  }
}
function DiffAndPatchComponent(oldComp, newComp, node) {
  if (oldComp.pearlId !== newComp.pearlId) {
    const opts = {
      parentNotElement: true,
      parents: getParentComponentsAndFrags(node, oldComp)
    };
    const newNode = render(newComp, opts);
    replaceWith(node, newNode);
    triggerMountedLifeCycle(newNode, newComp);
    return newNode;
  } else {
    diffAndPatch(oldComp.makeChild(), newComp.makeChild(), node);
  }
}
function diffAndPatchElement(oldTree, newTree) {
  const node = oldTree.domRef;

  if (oldTree.tag !== newTree.tag) {
    const hosts = [];
    let parentIsComp = false;

    if (Array.isArray(node.__ORBITON_CONFIG__.__nonElement_parents_hosted)) {
      parentIsComp = true;

      for (const item of node.__ORBITON_CONFIG__.__nonElement_parents_hosted) {
        if (item === parent) {
          break;
        } else {
          hosts.push(item);
        }
      }
    }

    const opts = {
      parentNotElement: parentIsComp,
      parents: parentIsComp ? hosts : undefined
    };
    const newNode = render(newTree, opts);
    replaceWith(node, newNode);
    triggerMountedLifeCycle(newNode);
    return newNode;
  }

  newTree.domRef = oldTree.domRef;
  patchNewEventListners(oldTree.events, newTree.events, node);
  PatchElementAttributes(oldTree.attributes, newTree.attributes, node);
  ingenimateChildren(oldTree.children, newTree.children, node);
}
function PatchElementAttributes(OldAttr, NewAttrs, node) {
  // Note: We first append all the new attributes
  // so that we can latter just remove the attributes that dont exits in the new attrs
  for (const [attr, value] of Object.entries(NewAttrs)) {
    // In this for loop we add atrributes and
    // also eveluate style objects and classnames.
    if (attr === "style") {
      if (OldAttr[attr] !== value) {
        node.setAttribute(attr, evaluateStyleTag(value));
      }
    } else if (attr.toLowerCase() === "classname") {
      if (OldAttr[attr] !== value) {
        node.setAttribute("class", value);
      }
    } else {
      if (OldAttr[attr] !== value) {
        node.setAttribute(getPropety(attr), value);
      }
    }
  } // We loop through the old attributes
  // if one of the old attributes is not in the neww attributes,
  // we ten remove it from the node


  for (const k in OldAttr) {
    if (!(k in NewAttrs)) {
      if (k.toLowerCase() === "className") {
        node.removeAttribute('class');
      } else {
        node.removeAttribute(getPropety(k));
      }
    }
  }
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
// Caser: children from fragment

function getFragHost(fragment) {
  const allNodes = allDocumentNodes();
  const result = []; // eslint-disable-next-line @typescript-eslint/no-unused-vars

  allNodes.forEach((el, _) => {
    if (el.__ORBITON_CONFIG__) {
      if (Array.isArray(el.__ORBITON_CONFIG__.__nonElement_parents_hosted)) {
        for (const item of el.__ORBITON_CONFIG__.__nonElement_parents_hosted) {
          if (item === fragment) {
            result.push(el);
            break;
          }
        }
      }
    }
  });
  return result;
}
function ingenimateChildren(OldChildren, NewChildren, node) {
  let index = 0;
  const childNodes$1 = childNodes(node);
  let parentNode;

  if (childNodes$1.length > 0) {
    parentNode = childNodes$1[0].parentNode;
  }

  for (let i = 0; i < OldChildren.length; i++) {
    const oldChild = OldChildren[i];
    const newChild = NewChildren[i];

    if (Array.isArray(oldChild) || Array.isArray(newChild)) {
      if (Array.isArray(newChild)) {
        if (Array.isArray(oldChild)) {
          // if both the new child and the old child are Arrays
          // we loop through the old child and get the index of each element and its corresponding element if the new child
          // we also get the DOM child at that index then diff them
          oldChild.forEach((item, ind) => {
            const newItem = newChild[ind];
            const added = CheckChildrenAndDiff(item, newItem, index, childNodes$1);
            index = index + added;
          });
          const additionalChidren = []; // if the new child has additional children longer than  the old child then have to append them to the dom too.

          for (const additionalChild of newChild.slice(oldChild.length)) {
            const DomChild = render(additionalChild);

            if (Array.isArray(DomChild)) {
              additionalChidren.push(...destructureArrays(DomChild));
            } else {
              additionalChidren.push(DomChild);
            }
          }

          const nextIndex = index;
          let nextNode = childNodes$1[nextIndex];

          if (nextNode !== undefined) {
            const parentNode = childNodes$1[0].parentNode;

            for (const iterator of additionalChidren) {
              parentNode.insertBefore(iterator, nextNode);
              index++;
              nextNode = childNodes$1[index];
            }
          } else {
            const parentNode = childNodes$1[0].parentNode;
            parentNode.append(...additionalChidren);
          }
        } else {
          const nodechild = childNodes$1[index];
          const nodeArr = [];
          newChild.forEach((item, ind) => {
            nodeArr.push(render(item));

            if (ind !== 0) {
              index++;
            }
          });
          replaceWith(nodechild, nodeArr);
        }
      }
    } else {
      const added = CheckChildrenAndDiff(oldChild, newChild, index, childNodes$1, parentNode);
      index = index + added;
    }
  }

  const ecessesChildren = [];

  for (const childEl of NewChildren.slice(OldChildren.length)) {
    const DomChild = render(childEl);
    ecessesChildren.push(DomChild);
  }

  if (ecessesChildren.length > 0) {
    appendChild$1(parentNode, ecessesChildren);
  }
}

function CheckChildrenAndDiff(oldChild, newChild, index, nodes, parentNode = null) {
  let added = 0;

  if (oldChild === undefined) {
    diffAndPatch(oldChild, newChild, nodes, parentNode);
  } else {
    if (oldChild.type === "Fragment") {
      const hosts = getFragHost(oldChild);
      added = added + hosts.length;
      diffAndPatch(oldChild, newChild, hosts);
    } else if (oldChild.type === "Component") {
      const hosts = getFragHost(oldChild);
      added = added + hosts.length;
      diffAndPatch(oldChild, newChild, hosts);
    } else {
      diffAndPatch(oldChild, newChild, nodes[index]);
      added++;
    }
  }

  return added;
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
function updateUITree(currentTree, workingProgressTree, ComponentRoot) {
  const newTree = PatchTrees(currentTree, workingProgressTree);
  const rootArr = getFragHost(ComponentRoot);
  let root;

  if (rootArr.length === 1) {
    root = rootArr[0];
  } else {
    root = rootArr;
  }

  diffAndPatch(currentTree, workingProgressTree, root);
  return newTree;
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

class Component extends BaseComponent {
  static isClassComponent = true;

  constructor(props = {}, context = {}) {
    super(props, context);

    if (props !== {}) {
      this.key = props ? props.key ? props.key : null : null;
    }

    this.type = 'Component';
    this.pearlId = createId(this.constructor.name, this.key);
    this.makeChild = this.makeChild.bind(this);
    this.Mounted = this.Mounted.bind(this);
    this.WillMount = this.WillMount.bind(this);
    this.getPearlId = this.getPearlId.bind(this);
    this.updateState = this.updateState.bind(this);
    this.changeState = this.changeState.bind(this);
  }

  getPearlId() {
    return this.pearlId;
  }

  Mounted() {}

  WillMount() {}
  /**
  * Updates a subset of the state in the class
  * @param {any} newState this subset that you want to update
  * @param {?Function} callback this callback function that is called after state updates
  *
  * */


  updateState(newState, callback = null) {
    this.changeState(newState, callback);
    const newTree = updateUITree(this.currentTree, this.render(), this);
    this.currentTree = newTree;
  }

  makeChild() {
    this.currentTree = this.render();
    return this.currentTree;
  }

  render() {
    return {
      tag: 'div'
    };
  }

}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
* The first time an element is rendered
*/

function initialRender(root, tree) {
  const replacedElement = render(tree);
  root.__orbiton__hosted__tree = tree;
  root.__ORBITON_CONFIG____isOrbitonRoot = true; //root.appendChild(replacedElement)

  appendChild$1(root, replacedElement);
  triggerMountedLifeCycle(root);
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
* appends a Tree to the DOM
*/

function append(Tree, root, callback) {
  initialRender(root, Tree);

  if (callback) {
    callback();
  }
}

/* eslint-disable */
function hydrate(element, node) {
  const childNodes = node.childNodes;

  if (element.type === "element") {
    hydrateElement(element, childNodes[0]);
  }

  triggerMountedLifeCycle(node);
}

function hydrateElement(element, node, opts = {}) {
  if (element.tag !== node.tagName.toLocaleLowerCase()) {
    throw new Error(`Its seems provided tree does node match with the DOM element.
Expected <${element.tag} ....>...</${element.tag}> but insted got <${node.tagName.toLocaleLowerCase()}>...</${node.tagName.toLocaleLowerCase()}>
    `);
  }

  node.__ORBITON_CONFIG__ = {};

  if (opts.parentNotElement) {
    node.__ORBITON_CONFIG__.__nonElement_parents_hosted = opts.parents;
  }

  if (element.attachedComponent) {
    node.__ORBITON_CONFIG__.attachedComponent = element.attachedComponent;
  }

  appendEvents(node, element.events);

  if (element.children && element.children.length > 0) {
    let index = -1;

    for (const child of element.children) {
      if (Array.isArray(child)) {
        for (const item of child) {
          index = hydrateChild(item, node, {}, index);
        }
      } else {
        index = hydrateChild(child, node, {}, index);
      }
    }
  }

  element.domRef = node;
  node.__ORBITON_CONFIG__.__element = element;
}

function hydrateChild(element, node, opts, index = 0) {
  let currentIndex = index;

  if (element.type === "Fragment") {
    currentIndex = hydrateFragment(element, node, opts, currentIndex);
  } else if (element.type === "element") {
    currentIndex++;
    hydrateElement(element, node.childNodes[currentIndex], opts);
  } else if (element.type === "Component") {
    currentIndex = hydrateComponet(element, node, opts, currentIndex);
  }

  return currentIndex;
}

function hydrateFragment(fragment, node, options = {}, startIndex = -1) {
  let currentIndex = startIndex;
  let parents = [];
  options.parentNotElement = true;
  let childOpts = {};

  if (Array.isArray(options.parents)) {
    parents = [...options.parents];
    parents.push(fragment);
  } else {
    parents.push(fragment);
  }

  for (const child of fragment.children) {
    childOpts = { ...options,
      parents: parents
    };

    if (child.type === "element") {
      currentIndex++;
      hydrateElement(child, node.childNodes[currentIndex], childOpts);
    } else if (child.type === "Fragment") {
      currentIndex = hydrateFragment(child, node, childOpts, currentIndex);
    } else if (child.type === "Component") {
      currentIndex = hydrateComponet(child, node, childOpts, currentIndex);
    }
  }

  return currentIndex;
}

function hydrateComponet(component, node, options = {}, startIndex = -1) {
  let currentIndex = startIndex;
  let parents = [];
  options.parentNotElement = true;
  let childOpts = {};

  if (Array.isArray(options.parents)) {
    parents = [...options.parents];
    parents.push(component);
  } else {
    parents.push(component);
  }

  let child = component.makeChild();
  childOpts = { ...options,
    parents: parents
  };

  if (child.type === "element") {
    currentIndex++;
    hydrateElement(child, node.childNodes[currentIndex], childOpts);
  } else if (child.type === "Fragment") {
    currentIndex = hydrateFragment(child, node, childOpts, currentIndex);
  } else if (component.type === "Component") {
    currentIndex = hydrateComponet(child, node, childOpts, currentIndex);
  }

  return currentIndex;
}

/**
 * Copyright (c) 2021 - present Beignana Jim Junior and other contributors.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
const version = "1.2.43";
/**
* A Javascript library for building Browser User Interfaces
* @author Beigana Jim Junior <jimjunior854@outlook.com>
* @copyright Beigana Jim Junior and Contributors © 2021 - present
* @license MIT
*
* Learn more at the official Documentation: {@link https://orbiton.js.org}
*/

const Orbiton = {
  withComponent,
  render,
  createElement,
  append,
  Component,
  createComponent,
  Fragment,
  BaseComponent,
  LogicalComponent,
  version,
  hydrate,
  Config
};

module.exports = Orbiton;
